{
  parserClass='com.vepanimas.intellij.prisma.lang.parser.PrismaParser'

  implements='com.vepanimas.intellij.prisma.lang.psi.PrismaElement'
  extends='com.vepanimas.intellij.prisma.lang.psi.impl.PrismaElementImpl'

  elementTypeHolderClass='com.vepanimas.intellij.prisma.lang.psi.PrismaElementTypes'
  elementTypeClass='com.vepanimas.intellij.prisma.lang.psi.PrismaElementType'
  tokenTypeClass='com.vepanimas.intellij.prisma.lang.psi.PrismaTokenType'

  psiClassPrefix='Prisma'
  psiImplClassSuffix='Impl'
  psiPackage='com.vepanimas.intellij.prisma.lang.psi'
  psiImplPackage='com.vepanimas.intellij.prisma.lang.psi.impl'

  tokens=[
    MODEL           = 'model'
    TYPE            = 'type'
    ENUM            = 'enum'
    GENERATOR       = 'generator'
    DATASOURCE      = 'datasource'

    UNSUPPORTED     = 'Unsupported'

    LBRACE          = '{'
    RBRACE          = '}'
    LPAREN          = '('
    RPAREN          = ')'
    LBRACKET        = '['
    RBRACKET        = ']'
    EQ              = '='
    DOT             = '.'
    COLON           = ':'
    QUEST           = '?'
    EXCL            = '!'
    AT              = '@'
    ATAT            = '@@'
    COMMA           = ','

    STRING_LITERAL  = 'regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?'
    NUMERIC_LITERAL = 'regexp:-?\d+(\.\d+)?'
    IDENTIFIER      = 'regexp:[a-zA-Z][a-zA-Z0-9\-_]*'
    WHITE_SPACE     = 'regexp:\s+'
  ]

  extends('FunctionCall|ArrayExpression|LiteralExpression|PathExpression')=Expression
  implements('(Model|Type|Enum|Datasource|Generator)Declaration|TypeAlias')='com.vepanimas.intellij.prisma.lang.psi.PrismaDeclaration'

  implements('.*Block')='com.vepanimas.intellij.prisma.lang.psi.PrismaBlock'
  mixin('.*Block')='com.vepanimas.intellij.prisma.lang.psi.impl.PrismaBlockMixin'

  implements('FieldDeclaration|EnumValueDeclaration|KeyValue')='com.vepanimas.intellij.prisma.lang.psi.PrismaMemberDeclaration'
}

Schema ::= Declaration*

private Declaration ::=
    ModelDeclaration
    | TypeDeclaration
    | EnumDeclaration
    | DatasourceDeclaration
    | GeneratorDeclaration
    | TypeAlias

ModelDeclaration ::= MODEL Identifier FieldDeclarationBlock {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaModelTypeDeclarationMixin"
    implements="com.vepanimas.intellij.prisma.lang.psi.PrismaModelTypeDeclaration"
}
TypeDeclaration ::= TYPE Identifier FieldDeclarationBlock {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaModelTypeDeclarationMixin"
    implements="com.vepanimas.intellij.prisma.lang.psi.PrismaModelTypeDeclaration"
}

FieldDeclarationBlock ::= '{' (FieldDeclaration | BlockAttribute)* '}'
FieldDeclaration ::= IDENTIFIER ':'? FieldType? FieldAttribute* {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaFieldDeclarationMixin"
}

EnumDeclaration ::= ENUM Identifier EnumDeclarationBlock {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaEnumDeclarationMixin"
}
EnumDeclarationBlock ::= '{' (EnumValueDeclaration | BlockAttribute)* '}'
EnumValueDeclaration ::= Identifier FieldAttribute* {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaEnumValueDeclarationMixin"
}

DatasourceDeclaration ::= DATASOURCE Identifier KeyValueBlock {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaConfigBlockDeclarationMixin"
}
GeneratorDeclaration ::= GENERATOR Identifier KeyValueBlock {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaConfigBlockDeclarationMixin"
}

KeyValueBlock ::= '{' KeyValue* '}'
KeyValue ::= Identifier '=' Expression {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaKeyValueMixin"
}

TypeAlias ::= TYPE Identifier '=' TypeReference FieldAttribute* {
    mixin="com.vepanimas.intellij.prisma.lang.psi.impl.PrismaTypeAliasMixin"
}

/* Types */
FieldType ::=
    UnsupportedOptionalListType
    | ListType
    | OptionalType
    | LegacyRequiredType
    | LegacyListType
    | TypeReference

UnsupportedType ::= UNSUPPORTED '(' STRING_LITERAL ')'
TypeReference ::= UnsupportedType | Identifier
UnsupportedOptionalListType ::= TypeReference '[' ']' '?'
ListType ::= TypeReference '[' ']'
OptionalType ::= TypeReference '?'
LegacyRequiredType ::= TypeReference '!'
LegacyListType ::= '[' TypeReference ']'

/* Attributes */
BlockAttribute ::= '@@' Path ArgumentsList?
FieldAttribute ::= '@' Path ArgumentsList?

/* Arguments */
ArgumentsList ::= '(' [Argument (',' Argument)*] ','? ')'
Argument ::= NamedArgument | Expression
NamedArgument ::= Identifier ':' Expression

/* Expressions */
Expression ::=
    FunctionCall
    | ArrayExpression
    | LiteralExpression
    | PathExpression

FunctionCall ::= Path ArgumentsList
ArrayExpression ::= '[' [Expression (',' Expression)*] ']'
LiteralExpression ::= NUMERIC_LITERAL | STRING_LITERAL
PathExpression ::= Path

/* Identifiers */
private Identifier ::= IDENTIFIER
Path ::= Identifier ('.' Path?)*